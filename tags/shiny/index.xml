<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shiny on Nan Xiao | 肖楠</title>
    <link>https://nanx.me/tags/shiny/</link>
    <description>Recent content in shiny on Nan Xiao | 肖楠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 30 Mar 2022 22:00:00 +0000</lastBuildDate><atom:link href="https://nanx.me/tags/shiny/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Architecting Large Shiny Apps with Minimal First Contentful Paint Time</title>
      <link>https://nanx.me/blog/post/shiny-fcp-loader/</link>
      <pubDate>Wed, 30 Mar 2022 22:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-fcp-loader/</guid>
      <description>The Shiny app skeleton is available from nanxstats/shiny-fcp-loader.
 Pantheon, Roma, Italy. Photo by Emma Fabbri.
 More than a few people asked me similar questions about this when building large shiny apps. Therefore, it might be time to formulate a simple solution with a minimalist yet extensible code demo.
UX side effects of large Shiny apps For larger Shiny apps, users could wait a long time (in terms of 10s of seconds) with an embarrassing blank screen before seeing the rendered app content.</description>
    </item>
    
    <item>
      <title>Self-Hosting Shiny Apps with Linode and Cloudflare</title>
      <link>https://nanx.me/blog/post/self-host-shiny-apps/</link>
      <pubDate>Wed, 26 Feb 2020 01:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/self-host-shiny-apps/</guid>
      <description>After procrastinating for some time, I finally set up a dedicated self-hosting server, nanx.app, for my public shiny apps. From now on, most of the web applications listed on my software page will be available from two mirrors — the self-hosting server and the public cloud hosting solution shinyapps.io kindly provided by RStudio.
A collection of my shiny apps, now also self-hosted.
 The Motivation I have built many shiny apps over the years — a few of them are public and open source.</description>
    </item>
    
    <item>
      <title>A List of Awesome Shiny Extension Packages</title>
      <link>https://nanx.me/blog/post/awesome-shiny-extensions/</link>
      <pubDate>Tue, 04 Dec 2018 14:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/awesome-shiny-extensions/</guid>
      <description>“Everything looks official with tiny leaves around it.” Original photo by Kelli Tungay.
  TL;DR: here is a curated list of R packages that offer extended UI or server components for Shiny: nanxstats/awesome-shiny-extensions. Pull requests welcomed!
 Five years ago, I wrote my first research software paper, and it eventually got published in Bioinformatics. If you know me, it’s probably not surprising that the paper was about an R package and a companion Shiny app.</description>
    </item>
    
    <item>
      <title>Shiny Now Supports Async Execution</title>
      <link>https://nanx.me/blog/post/shiny-async/</link>
      <pubDate>Mon, 21 May 2018 14:15:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-async/</guid>
      <description>Shiny is my favorite web application framework. It is simply awesome. Shiny 1.1.0 was released to CRAN last week. This update brings probably the most significant feature/improvement in recent years: async execution support. With the help of future, promises (computer science people surely knew how to name abstract things…), and this shiny update, you can now write scalable web applications using Shiny.
You Want It When? (Zootopia)
  In brief, if you have some long-running computations (such as querying a remote database, live fitting a statistical model) in your Shiny app, that computation would block additional users to use the app simultaneously, until that computation is finished.</description>
    </item>
    
  </channel>
</rss>
