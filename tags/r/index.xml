<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Nan Xiao | 肖楠</title>
    <link>https://nanx.me/tags/r/</link>
    <description>Recent content in R on Nan Xiao | 肖楠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 20 Aug 2022 00:15:00 +0000</lastBuildDate><atom:link href="https://nanx.me/tags/r/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Automate HTML to PDF Printing with {promises} and {chromote}</title>
      <link>https://nanx.me/blog/post/chromote-pdf-automation/</link>
      <pubDate>Sat, 20 Aug 2022 00:15:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/chromote-pdf-automation/</guid>
      <description>The R code in this post is also available in this GitHub Gist.
Photo by Bank Phrom.
chromote is an R package that allows one to automate tasks driven by web browsers. It works by providing an API to communicate with Chromium-based browsers via the Chrome DevTools Protocol (CDP). For example, CDP can help us load and print HTML pages to PDF files programmatically, similar to what one could do in the web browser GUI but with mouse clicks.</description>
    </item>
    
    <item>
      <title>The Past and Future of Shiny Keynote at rstudio::conf(2022)</title>
      <link>https://nanx.me/blog/post/shiny-keynote-rstudio-conf/</link>
      <pubDate>Wed, 17 Aug 2022 20:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-keynote-rstudio-conf/</guid>
      <description>I constantly feel lucky to witness the growth of the R web framework, Shiny, in the past ten years. In his keynote speech at rstudio::conf 2022, Joe Cheng shared an excellent summary of Shiny’s achievements and exciting outlook.
I am deeply moved by the story about how Shiny was created and Joe’s journey, and I recommend you watch the talk recording below if you haven’t. Notably, after Hadley’s Mastering Shiny book, the community-maintained awesome list awesome-shiny-extensions was again highlighted in Joe’s talk from 24:00 to 24:33 (thanks so much for the shout-out!</description>
    </item>
    
    <item>
      <title>Parsing Human-Readable Text Data from the Web with Readability.js and R</title>
      <link>https://nanx.me/blog/post/r-readability-parser/</link>
      <pubDate>Tue, 02 Aug 2022 01:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/r-readability-parser/</guid>
      <description>The R and JavaScript code to reproduce the results in this post is available from https://github.com/nanxstats/r-readability-parser.
Photo by Nick Hillier.
Readability.js Maybe you have used tools like rvest to harvest text data from web pages. Naturally, this often requires elaborated human efforts in the front to understand the structure of the target website.
The picture looks quite different when we think at the web scale. To parse the content of many more sites and many more types of pages, we need to make our tool adaptive enough to extract the most relevant text instead of purely relying on manually crafted logic.</description>
    </item>
    
    <item>
      <title>The zlib Algorithm for Text/Binary File Classification</title>
      <link>https://nanx.me/blog/post/txtvsbin/</link>
      <pubDate>Tue, 14 Jun 2022 20:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/txtvsbin/</guid>
      <description>The R code in this post is also available at this GitHub Gist.
Photo by Alp Duran.
Intro In some situations, we want to know whether a file is a text file or a binary file programmatically. For example, as a text editor developer, you can use this information to choose the correct editing interface (text editor or hex editor). Similarly, if you want to pack or compress a collection of files into a compact format, it helps to know the type of file before encoding them.</description>
    </item>
    
    <item>
      <title>Sensible Defaults</title>
      <link>https://nanx.me/blog/post/sensible-defaults/</link>
      <pubDate>Tue, 07 Jun 2022 00:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/sensible-defaults/</guid>
      <description>Photo by Thomas Reaubourg.
gtsummary The other day, I looked into Daniel Sjoberg’s gtsummary package for summarizing tabular data and regression models. The README says:
The {gtsummary} package summarizes data sets, regression models, and more, using sensible defaults with highly customizable capabilities.
The concept of having sensible defaults in (research) software immediately resonated with me. Ideally, the default settings in software should be able to support the majority of users’ needs.</description>
    </item>
    
    <item>
      <title>Honey, I Serialized the Data</title>
      <link>https://nanx.me/blog/post/r-serialize-timemachine/</link>
      <pubDate>Sun, 01 May 2022 20:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/r-serialize-timemachine/</guid>
      <description>The R code to reproduce the results in this post is available from https://github.com/nanxstats/r-serialize-timemachine.
Photo by Alex Gogan.
A mystery on serialize() Serialization/deserialization is an important topic for exchanging data efficiently at scale. In R, there is a native choice for this: serialize()/unserialize() and their more convenient interface saveRDS()/readRDS().
Yihui once asked why the first 14 bytes in R serialized data were skipped in digest::digest(), instead of the first 17 bytes for the binary format, as the additional three filling zero-bytes are always there.</description>
    </item>
    
    <item>
      <title>Five Minute Shiny: Skeleton Loading Screen</title>
      <link>https://nanx.me/blog/post/shiny-loading-skeleton/</link>
      <pubDate>Sun, 24 Apr 2022 21:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-loading-skeleton/</guid>
      <description>The Shiny app template is available from nanxstats/shiny-loading-skeleton. Preview the demo at shinyapps.io.
Mosaic American Gothic. Original photo by Simon Lee.
Let’s implement a “skeleton loader” for Shiny apps. A typical animated skeleton loading screen looks like this:
A demo Shiny app with a skeleton loader. Recorded with QuickTime and converted by gifski.
Compared to the traditional loading screens provided by tools like waiter, the skeleton loading screen is a prominent way to show the app is currently loading and can give users an idea of the incoming page structure.</description>
    </item>
    
    <item>
      <title>Five Minute Shiny: File Input Area Widget</title>
      <link>https://nanx.me/blog/post/shiny-file-input-area/</link>
      <pubDate>Sun, 17 Apr 2022 21:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-file-input-area/</guid>
      <description>The R code in this post is also available as this GitHub Gist.
Photo by Willian Justen de Vasconcellos
Our goal today is to implement a file input area widget for Shiny. Compared to a regular file input button, a larger file input UI helps users focus on the task where an upload action is the central flow of the web application.
Fortunately, the native shiny::fileInput() offers a solid foundation for customization, as it already supports both click-to-browse and drag-and-drop for file selection.</description>
    </item>
    
    <item>
      <title>Five Minute Shiny: Implement the Missing Switch Input with Bootstrap 5</title>
      <link>https://nanx.me/blog/post/shiny-bs5-switches/</link>
      <pubDate>Thu, 14 Apr 2022 00:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-bs5-switches/</guid>
      <description>The R code in this post is also available as this GitHub Gist.
Photo by Zonduurzaam Deventer.
Bootstrap 4 and 5 have expanded the types of UI components compared to version 3. On the other hand, the available UI inputs and outputs in Shiny have been relatively stable while being carefully made compatible across different Bootstrap versions through bslib.
Since we can already leverage the native UI components in Bootstrap 5 via bslib, it would be fun to create the R wrappers for the “missing” inputs that were not available in Bootstrap 3.</description>
    </item>
    
    <item>
      <title>Building Paginated News Lists in R Markdown and Shiny with DT</title>
      <link>https://nanx.me/blog/post/dt-news-list/</link>
      <pubDate>Sun, 10 Apr 2022 01:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/dt-news-list/</guid>
      <description>The R code in this post is also available as this GitHub Gist.
Mosaic Mondrian. Original photo by Simon Lee.
Context and motivation A single-file R Markdown document often generates single-page HTML outputs. Similarly, Shiny is a single-page application framework. The single-page nature of these outputs makes it challenging to create experiences like pagination to display long and sophisticated lists, which is usually accomplished by creating multiple pages and URL routing.</description>
    </item>
    
    <item>
      <title>Adaptive ggplot2 Color Scales with Color Interpolation</title>
      <link>https://nanx.me/blog/post/ggplot2-color-interpolation/</link>
      <pubDate>Wed, 06 Apr 2022 01:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/ggplot2-color-interpolation/</guid>
      <description>Photo by Mateo Giraud.
My R package ggsci has included a few popular discrete color palettes. The colors values in these palettes are not automatically generated from a color space but hand-picked instead, often containing only five to ten distinct colors. A frequent question from the users is: What should I do when the colors are running out due to a more significant number of categories in the data?</description>
    </item>
    
    <item>
      <title>Architecting Large Shiny Apps with Minimal First Contentful Paint Time</title>
      <link>https://nanx.me/blog/post/shiny-fcp-loader/</link>
      <pubDate>Wed, 30 Mar 2022 22:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/shiny-fcp-loader/</guid>
      <description>The Shiny app skeleton is available from nanxstats/shiny-fcp-loader.
Pantheon, Roma, Italy. Photo by Emma Fabbri.
More than a few people asked me similar questions about this when building large shiny apps. Therefore, it might be time to formulate a simple solution with a minimalist yet extensible code demo.
UX side effects of large Shiny apps For larger Shiny apps, users could wait a long time (in terms of 10s of seconds) with an awkward blank screen before seeing the rendered app content.</description>
    </item>
    
    <item>
      <title>A Simple Link Checker for Hugo and Blogdown Websites</title>
      <link>https://nanx.me/blog/post/link-checker/</link>
      <pubDate>Tue, 22 Feb 2022 20:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/link-checker/</guid>
      <description>Photo by Katie Treadway.
Some background I have been blogging with Hugo/blogdown for a while. One housekeeping task I have always wanted to automate with R is scanning the entire website to ensure that all the links are still working. It is essential for maintaining an enjoyable reading experience without archiving too many external links.
Conceptually, the requirement for a generic broken link checker is quite simple:
Get the links to all pages on the site.</description>
    </item>
    
    <item>
      <title>Font Variant Numeric</title>
      <link>https://nanx.me/blog/post/font-variant-numeric/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/font-variant-numeric/</guid>
      <description>TL;DR: If you use the native font stack (the default in Bootstrap 4+), check the numbers displayed in tables, especially on Apple’s platforms.
Photo by Jen Theodore.
A new problem Many of the content creation frameworks that support HTML output in the R world are getting upgraded to Bootstrap 4+:
Shiny and R Markdown can use bslib to customize Bootstrap version; The three-column Bootstrap style for bookdown projects; The pkgdown 2.</description>
    </item>
    
    <item>
      <title>More Than 1,500 File Extensions Are Used Inside R Packages</title>
      <link>https://nanx.me/blog/post/cran-file-exts/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/cran-file-exts/</guid>
      <description>The R code to reproduce the results is available from the GitHub repo nanxstats/cran-file-exts.
Photo by Pawel Czerwinski.
When applied correctly, file extensions can be informative. They are the very first clue on handling a specific file without parsing the file content.
To properly capture and classify files in source R packages, I am interested in learning what file extensions are frequently used by R packages.
We can achieve this easily by downloading all R packages available from CRAN one at a time and collect the file extensions inside:</description>
    </item>
    
    <item>
      <title>Rebranding R Packages with Hexagon Stickers: A Minimalist Approach</title>
      <link>https://nanx.me/blog/post/rebranding-r-packages-with-hexagon-stickers/</link>
      <pubDate>Mon, 08 Feb 2021 01:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/rebranding-r-packages-with-hexagon-stickers/</guid>
      <description>A new hex sticker wall of my R packages.
I have built a few R packages over the years. I have always been adding some forms of an ad hoc logo to them, trying to make a visual impression. As the portfolio size grows larger, I realized that I would need a principled way to create the logos and refresh my packages’ look. Hexagon stickers seem to be an acceptable form of logos that are heavily used by the R community.</description>
    </item>
    
    <item>
      <title>Bayesian Lasso with greta</title>
      <link>https://nanx.me/blog/post/bayesian-lasso-with-greta/</link>
      <pubDate>Mon, 07 Dec 2020 20:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/bayesian-lasso-with-greta/</guid>
      <description>The R code to reproduce the results is available from GitHub Gist.
Horseshoe Bend, Arizona. Photo by Madeline Pere.
Although I am not an expert in Bayesian statistics, I always have an idealized version of the framework for Bayesian modeling in my mind:
Allows defining data models intuitively — preferably in native R. Handles the low-level computations such as MCMC automatically. Works on both CPU and GPU seamlessly would be perfect for 2020.</description>
    </item>
    
    <item>
      <title>Fuzz Testing Your R Code</title>
      <link>https://nanx.me/blog/post/fuzz-testing-your-r-code/</link>
      <pubDate>Mon, 28 Sep 2020 22:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/fuzz-testing-your-r-code/</guid>
      <description>Good software requires even better testing. Particularly, unit testing has been widely used by many R packages as a tool for reducing the number of bugs and improving code structure. A unit test is often written when a single unit of functionality is created in the program. Is there a good way to test a large program or system after it is created? The answer is yes, and one of the approaches people developed is fuzz testing.</description>
    </item>
    
    <item>
      <title>Customize Syntax Highlighting for R distill Websites</title>
      <link>https://nanx.me/blog/post/distill-syntax-highlight/</link>
      <pubDate>Fri, 22 May 2020 00:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/distill-syntax-highlight/</guid>
      <description>“Diversity is essential to happiness, and in Utopia there is hardly any.” (Bertrand Russell) Photo by @chuttersnap.
The Problem The distill (formerly radix) package offers an excellent option in the R Markdown ecosystem to create beautifully typed websites. I was using it one day and looking into customizing the syntax highlighting theme. Then I found this issue:
I was a bit surprised and sad that there is no easy way to customize it.</description>
    </item>
    
    <item>
      <title>Disposable Computing with callr</title>
      <link>https://nanx.me/blog/post/disposable-computing-with-callr/</link>
      <pubDate>Sat, 11 Apr 2020 17:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/disposable-computing-with-callr/</guid>
      <description>Photo by @uniqueton.
Runtime errors can be tricky and costly to resolve for any programming language, and these errors frequently happen when managing (file) connections. Boris posted such an issue when using my R package Rcpi. I rephrase it here as:
library(&amp;quot;Rcpi&amp;quot;) dir.create(&amp;quot;test&amp;quot;) for (i in 1:2000) { file.copy( system.file(&amp;quot;compseq/DB00530.sdf&amp;quot;, package = &amp;quot;Rcpi&amp;quot;), paste0(&amp;quot;test/&amp;quot;, i, &amp;quot;.sdf&amp;quot;) ) } fns &amp;lt;- list.files(&amp;quot;test/&amp;quot;, pattern = &amp;quot;.sdf$&amp;quot;, full.names = TRUE) for (i in 1:length(fns)) { cat(&amp;quot;\014&amp;quot;, i, &amp;quot;\n&amp;quot;) Rcpi::convMolFormat(infile = fns[i], outfile = &amp;quot;temp.</description>
    </item>
    
    <item>
      <title>Self-Hosting Shiny Apps with Linode and Cloudflare</title>
      <link>https://nanx.me/blog/post/self-host-shiny-apps/</link>
      <pubDate>Wed, 26 Feb 2020 01:00:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/self-host-shiny-apps/</guid>
      <description>After procrastinating for some time, I finally set up a dedicated self-hosting server, nanx.app, for my public shiny apps. From now on, most of the web applications listed on my software page will be available from two mirrors — the self-hosting server and the public cloud hosting solution shinyapps.io kindly provided by RStudio.
A collection of my shiny apps, now also self-hosted.
The Motivation I have built many shiny apps over the years — a few of them are public and open source.</description>
    </item>
    
    <item>
      <title>New Packages on CRAN: tidycwl and biocompute</title>
      <link>https://nanx.me/blog/post/tidycwl-biocompute/</link>
      <pubDate>Sat, 14 Dec 2019 00:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/tidycwl-biocompute/</guid>
      <description>On the journey of achieving reproducibility in genomic data analysis projects, one often faces challenges with documenting workflows and computations systematically. To provide one way for tackling these problems, we (me and my colleagues) have recently released two new R packages — tidycwl and biocompute — to CRAN.
tidycwl As the name implies, the package tidycwl aims at offering a native toolchain for R to analyze tools and workflows written in the Common Workflow Language (CWL), while following the tidyverse design principles.</description>
    </item>
    
    <item>
      <title>Building Regularized Logistic Regressions from Scratch with Computational Graphs in R</title>
      <link>https://nanx.me/blog/post/cgraph-logreg/</link>
      <pubDate>Sun, 06 Oct 2019 00:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/cgraph-logreg/</guid>
      <description>The R package built for this post is available on GitHub: nanxstats/logreg.
Update 2020-02-11: there has been some major API updates and improvements since cgraph 5.0.0. The logreg package is now updated to reflect these changes. The code example in this post is updated, too.
As one of the cornerstones for deep learning frameworks, automatic differentiation was briefly mentioned in our previous post. Today let’s focus on the other important piece: the computational graph.</description>
    </item>
    
    <item>
      <title>A List of Awesome Shiny Extension Packages</title>
      <link>https://nanx.me/blog/post/awesome-shiny-extensions/</link>
      <pubDate>Tue, 04 Dec 2018 14:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/awesome-shiny-extensions/</guid>
      <description>“Everything looks official with tiny leaves around it.” Original photo by Kelli Tungay.
TL;DR: here is a curated list of R packages that offer extended UI or server components for Shiny: nanxstats/awesome-shiny-extensions. Pull requests welcomed!
Five years ago, I wrote my first research software paper, and it eventually got published in Bioinformatics. If you know me, it’s probably not surprising that the paper was about an R package and a companion Shiny app.</description>
    </item>
    
    <item>
      <title>General-Purpose Programming with R</title>
      <link>https://nanx.me/blog/post/general-purpose-programming-with-r/</link>
      <pubDate>Thu, 25 Oct 2018 23:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/general-purpose-programming-with-r/</guid>
      <description>“They’ll take your soul if you let them — don’t let them.” (Carole King, You’ve Got a Friend) Photo by Jelleke Vanooteghem.
I used R for almost every single computational task I do on my computer in the past ten years. I use R for things that are not simply statistics (pun intended), but everything related to data, or everything that can be done programmatically.
Recently, I found a fascinating thread posted in the r/rstats subreddit.</description>
    </item>
    
    <item>
      <title>Implementing Triplet Losses for Implicit Feedback Recommender Systems with R and Keras</title>
      <link>https://nanx.me/blog/post/triplet-loss-r-keras/</link>
      <pubDate>Wed, 29 Aug 2018 19:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/triplet-loss-r-keras/</guid>
      <description>All the R code for this post is available on GitHub: nanxstats/deep-learning-recipes.
Photo: Three Palms by Jamie Davies
At the end of our last post, I briefly mentioned that the triplet loss function is a more proper loss designed for both recommendation problems with implicit feedback data and distance metric learning problems. For its importance in solving these practical problems, and also as an excellent programming exercise, I decided to implement it with R and Keras.</description>
    </item>
    
    <item>
      <title>Prototyping a Recommender System for Binary Implicit Feedback Data with R and Keras</title>
      <link>https://nanx.me/blog/post/recsys-binary-implicit-feedback-r-keras/</link>
      <pubDate>Wed, 22 Aug 2018 17:30:00 +0000</pubDate>
      
      <guid>https://nanx.me/blog/post/recsys-binary-implicit-feedback-r-keras/</guid>
      <description>Ten years ago, the Netflix prize competition made a significant impact on recommender systems research. In the same time, such benchmark datasets, including MovieLens, are a bit misleading: in reality, implicit feedback data, or binary implicit feedback data (someone interacted with something) could be the best we can have. One to five star ratings type of continuous response data could be challenging to get or impossible to measure.
Photo: One in A Million by Veronica Benavides</description>
    </item>
    
  </channel>
</rss>
